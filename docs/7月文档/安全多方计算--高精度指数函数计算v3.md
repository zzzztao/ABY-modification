# 安全多方计算--高精度指数函数计算

## 协议介绍：

在安全计算电路中计算e^x

在二进制下利用指数基底精确表示指数函数，基于布尔共享进行高效指数计算。



## 协议内容：

### 当指数为整数时：

1. 初始化二进制基底
   $$
   B_0 = e^{2^0},B_1 = e^{2^1},B_2 = e^{2^2},B_3 = e^{2^3},B_4 = e^{2^4},...,B_i=e^{2^i}
   $$

2. 把x换算成二进制：
   $$
   x = a_0*2^0+a_1*2^1+a_2*2^2+...+a_n*2^n
   $$

3. 计算：
   $$
   e^x = B_0^{a_0}B_1^{a_1}...B_n^{a_n}
   $$

e.g.
$$
23 = 1+1*2+1*2^2+0*2^3+1*2^4 \quad\ 23 = (10111)_B \\
则:e^{23} = B_0^{1}B_1^{1}B_2^{1}B_3^{0}B_4^{1}
$$

### 当指数为小数时：

1. 初始化二进制基底：
   $$
   B_0 = e^{2^0},B_1 = e^{2^1},B_2 = e^{2^2},B_3 = e^{2^3},B_4 = e^{2^4},...,B_i=e^{2^i} \\B_{-1} = e^{\frac{1}{2}},B_{-2} = e^{(\frac{1}{2})^{2}},,B_{-3} = e^{(\frac{1}{2})^{3}},...,,B_{-i} = e^{(\frac{1}{2})^{i}}
   $$

2. 将x转化为标准IEEE  754浮点数表示. 取出阶码i
   $$
   x = a_0*2^0+a_1*2^1+a_2*2^2+...+a_i*2^i +a_{i+1}*2^{-1},...,a_{n}*2^{-(n-i)}
   $$
   
3. 计算：
   $$
   e^x = B_0^{a_0}B_1^{a_1}...B_i^{a_i}B_{-1}^{a_{i+1}}...B_{-(n-i)}^{a_n}
   $$
   

e.g. 

$$
178.125 = (10110010.001)_B \\
$$
转换成二进制浮点数即为：
$$
1.0110010001*2^{111}
$$

数符: 由于浮点数是正数，故为0.(负数为1)
阶码: 阶码是需要作移码运算，在转换出来的二进制数里，阶数是111(十进制为7)，对于单精度的浮点数，偏移值为01111111(127)[偏移量的计算是：2^(e-1)-1, e为阶码的位数，即为8，因此偏移值是127]，即：111+01111111 = 10000110
尾数: 小数点后面的数，即0110010001

小数点前面的1默认是不表示的，规格化表示后最高位总是”1“，所以就直接隐藏了。

| 数符 |   阶码   |          尾数           |
| :--: | :------: | :---------------------: |
|  0   | 10000110 | 01100100010000000000000 |



## 接口定义：

```c++
//输出小数点偏移量
share* decimalPlace(share *s_x, uint32_t bitlen, BooleanCircuit *circ){
    
}

// 利用明文偏移量计算指数
//bitlen：位数；dp：偏移量；s_exponent：要计算的指数x；circ：布尔电路
share* binaryExponentFloat(uint32_t bitlen, uint32_t dp, share* s_exponent, BooleanCircuit* circ);


//bitlen：位数；dp：偏移量；s_exponent：要计算的指数x；circ：布尔电路
share* binaryExponentDouble(uint32_t bitlen, uint32_t dp, share* s_exponent, BooleanCircuit* circ);


```

